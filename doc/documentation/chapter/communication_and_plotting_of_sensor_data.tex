\chapter{Communication and plotting of sensor data}
\label{ch:interface_pages}
IoT devices keep measuring sensor data but also need to be ready to receive commands all the time. As all current and past measurements need to be available to the user at all times, the system needs to log data and pass current measurements in real-time. The best place to log data is the server, as multiple IoT devices can connect to the same database and all logged data is always available, even if a device loses its' connection to the server. Also, the data must be sent to the client and finally needs to be displayed on the control panel. But the system not only needs to pass data from the IoT devices to the client, but it also needs to provide a way to send commands from the user interface via the server to any IoT device.



\section{MQTT communication between the IoT device and the server}
\label{sec:mqtt}
The communication between any IoT device and the server is implemented using MQTT. Both the device and the server connect to an MQTT broker that handles the routing of all data being sent. The device publishes data to the topic [PASTE TOPIC IF AVAILABLE] in one of the following formats:

format of pressure data

format of fan speed data

The server connects to the MQTT broker as a client and subscribes to the same topic. Each data being published on that topic will trigger an event listener on the server.
When the server receives data, it will automatically check whether it contains information about the pressure or fan speed. Then, the data will directly get logged using the central SQLite database. The following two tables store all logging data:

\begin{lstlisting}[label = lst:users, language = SQL, numbers = none]
CREATE TABLE pressure(timestamp INT, pressure INT);
CREATE TABLE fan_speed(timestamp INT, fan_speed INT);
\end{lstlisting}

For each dataset received, a new entry will be added to one of the tables.  The timestamp saved to the database contains a newly generated timestamp and not the data received from the IoT device. In distributed systems, there is no such thing as real-time. To make data from different sources comparable, the server sets timestamps itself. That means, that if two entries to different tables have the same timestamp,  the data has actually been received by the server at the same time. If a client is connected to the server and currently using the control panel, the received data will get directly forwarded using WebSocket (chapter \ref{sec:websocket}). This ensures, that the client will receive all data in real-time. There is no need to frequently send requests to the server to fetch data from the database to keep the plotted data up to date.

[ADD DESCIPTION FOR SENDING COMMANDS VIA MQTT]



\section{WebSocket communication between the server and the client}
\label{sec:websocket}
Data that needs to be sent to the client only once is being fetched by the client using get requests. But if a plot displaying data needs to show real-time data, it is quite inefficient to fetch data from the server at a high frequency. The server would need to read data from the database or a buffer all the time and the client might request data a lot of times even if no new data has been sent from the IoT device.
A better way of dealing with this problem is using WebSocket. Using WebSocket the server can establish a consistent connection to the client. Data can be sent in both directions at all times and receiving a message will trigger an event handler that can process the data. To make this kind of communication possible, the server creates a WebSocket server listening on port 8000. The client connects to this server as a client as soon as the user opens the control panel. After a connection has been established, the server creates a separate MQTT subscriber (chapter \ref{sec:mqtt}) that instantly forwards all data received via MQTT to the client. This means, that the client only needs to listen to incoming messages from the WebSocket to receive all sensor data in real-time.



\section{Displaying sensor data on the control panel}
\label{sec:display_control_panel}
To display sensor data on the control panel, the client generates two plots, one for pressure and one for fan speed data. The free open-source library Chart.js can be used to plot data in a lot of ways. In this case, basic lined plots will show the pressure and fan speed over time.  The parameters of the plots can easily be adjusted to fit the given range of 0-120Pa for displaying the pressure and 0-100\% for displaying the fan speed. The x-axis will automatically be labeled depending on the data that gets assigned to it. To display the timestamps in a readable format, the values get formatted before assigning them to the plot. Depending on the selected time interval, the plot will either show a date (\textit{DD.MM.YYYY}) or a time (\textit{HH:MM:SS}) for each data point.



\subsection{Requesting and updating sensor data}
\label{subsec:request_sensor_data}
As described in chapter \ref{sec:websocket}, the client receives new data via WebSocket. But that does not tell anything about the former state of the sensors. To display a former set of data, the client needs to send a get request to the server.  As the user can choose between different time intervals to display data, the timestamp of the oldest data to be displayed will get passed alongside an indicator of whether pressure or fan speed information is being requested.  The server will select the corresponding entries from the database and will return a set of data that can then be plotted on the control panel. Every time a user switches from another page of the interface to the control panel, a get request is being sent for both of the plots. After receiving a response, the client will generate a new plot with the received data. If the user changes the time interval, the current plot will get deleted, a new get request will get sent and a new plot will get generated afterward.
After the plot has been generated, there is no need to generate a whole new plot every time the client receives new data. The new data can just be appended to the current dataset and the plot can get updated without reinitialization.



\subsection{Plotting sensor data}
\label{subsec:plot_sensor_data}
Plotting sensor data using Chart.js is quite simple. After creating a new chart element and adding it to a canvas, the only thing one needs to do is assigning data for the x- and y-axis. To display data properly, the parameters for colors, minimum and maximum values, width, and line type have been adjusted to match the requirements. Adjustments can be made by editing the  \textit{type},  \textit{data} and  \textit{options} parameters of the charts. To make the trends of the data even more comprehensible, the \textit{tension} parameter has been set to 0.4 which provides interpolation between the single measurements.



\section{Sending commands to the IoT device}
\label{subsec:send_command}
